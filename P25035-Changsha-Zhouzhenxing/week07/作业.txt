1、请将 "1,2,3"，变成 ["1","2","3"]
"1,2,3".split(',')

2、使用Python copy一个文件，从a目录,copy文件到b目录

import shutil


def copy():
    filename = "12.pdf"   

    oldname = u'E:\\a\\' + filename
    newname = u"E:\\b\\" + filename
    shutil.copyfile(oldname, newname)
    print('已复制'+filename)

if __name__ == '__main__':
    copy()



3、以下代码输出什么，请解释原因(写到问题下方):
li = [ [ ] ] * 5
li[0].append(10)
print(li)  

#上面的print输出 [[10], [10], [10], [10], [10]]。
原因为 [[]] * 5 结果是在一个数组里面拷贝了5个[],变成了[[],[],[],[],[]]，因为[]为引用类型，外层列表里面的元素是列表，这些列表的拷贝直接是拷贝的引用，指向的内存地址相同，属于浅拷贝。
li[0].append(10) 虽然是在li第一个元素列表中append了10，但是因为后续的4个列表元素都是指向的同一个地址，所以实际指向的内容都是一样的，
print出来就是[[10], [10], [10], [10], [10]]，各个元素的值都是一样的了。

li[1].append(20)
print(li)
#上面的print输出[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]。
li[1].append(20)的原理是一样的和li[0].append(10)，虽然是在第2个元素中append，但是因为各个列表元素指向的地址相同，
一个元素列表append 20，相当于各个元素列表都append 20。

li.append(30)
print(li) 
#上面的print输出[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20],30]
# 外层列表增加一个元素30

# 不错,基本概念和方法都掌握的很好, 深层拷贝的概念理解的还不够透彻,可以尝试一下双层列表和三层列表,加深一下理解.
